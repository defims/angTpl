<!doctype html>
<head>
    <meta charset="utf8"/>
    <link rel="stylesheet" href="style.css">
    <script src="controllers.js"></script>
    <!--<script src="../angularMobile.js"></script>-->
</head>
<body data-app>
    <ul data-controller="controller">
        <li data-controller="controller2" data-repeat="phone in phones">
            {{phone.name}}{{phone.snippet}}
            <p data-event-click="">{{phone.snippet}}</p>
            <img data-attribute-src="text{{phone.img}}content"/>
        </li>
        <li>{{item.child}}</li>
        <li data-repeat="item in phones">
            {{item.name}}
        </li>
    </ul>
    <!--<div id='1'>
        <div id='2'>
            <div id='3'>
                <div id='4'></div>
           </div>
            <div id='5'>
                <div id='6'></div>
            </div>
            <div id='7'></div>
        </div>
        <div id='8'></div>
    </div>-->
<script>
/*
Copyright (c) 2013 Defims Loong https://github.com/defims/PubSub
License: GPL v2

https://github.com/defims/PubSub
*/

(function(root, factory){
	'use strict';

	// CommonJS
	if (typeof exports === 'object' && module){
		module.exports = factory();

	// AMD
	} else if (typeof define === 'function' && define.amd){
		define(factory);
	// Browser
	} else {
		root.PubSub = factory();
	}
}( ( typeof window === 'object' && window ) || this, function(){
    
    /*
     *  Node
     */
    var Node = function(){
        this.key;
        this.parent;
        this.children           = [];
        this.subscribers        = [];
    };


    /*
     *  TopicTree
     */

    var TopicTree   = function(){
        this.root               = new Node;
        this.current            = this.root;
        this.length             = 0;
        this.subscribersByToken = [];
    };
    TopicTree.prototype = {
        getNode : function(/*Array*/path){
            var node    = this.current,
                match   = false,
                len,children,key;
            while(path.length){
                key         = path.shift();
                match       = false;
                children    = node.children;
                len         = children.length;
                while(len--){
                    node    = children[len];
                    if(node.key == key){
                        match   = true;
                        break;
                    }
                }
            }
            return (match ? node : false);
        },
        mount   : function(/*Array*/path, /*function*/func){
            var node        = this.current,
                token       = ++this.length,
                key,len,children,match;
            while(path.length){
                key         = path.shift();
                match       = false;
                parent      = node;
                children    = node.children;
                len         = children.length;
                while(len--){
                    node   = children[len];
                    if(node.key == key){
                        match   = true;
                        break;
                    }
                }
                if( !match ){
                    node          = new Node;//change reference
                    node.key      = key;
                    node.parent   = parent;
                    parent.children.push(node);
                }
            }
            node.subscribers.push({"token": token, "func" : func});
            this.subscribersByToken[token] = {"node": node, "id": node.subscribers.length - 1};
            return token;
        },
        unmountByToken  : function(token){
            var item            = this.subscribersByToken[token],
                node            = item.node,
                subscribers     = node.subscribers,
                id              = item.id;
            node.subscribers    = subscribers.slice(0,id).concat(subscribers.slice(id+1, subscribers.length));
        },
        unmountByPath   : function(path){
            this.getNode(path).subscribers  = [];
        }
    };


    /*
     *  PubSub
     *
     */
    var PubSub  = function(){
        this.topicTree  = new TopicTree;
    };
    PubSub.prototype    = {
        message2path    : function(message){
            return message.replace(/[\.\[]/gim,'/').replace(/\]/gim,'').split('/');
        },
        setMessageRoot  : function(messageRoot){
            var topicTree       = this.topicTree;
            topicTree.current   = topicTree.getNode(this.message2path(messageRoot));
        },
		restoreMessageRoot	: function(){
			//use memento	
		},
        publish         : function(message, args){
            var node    = this.topicTree.getNode(this.message2path(message)); 
            if(!node) return false;
            var subscribers = node.subscribers,
                len         = subscribers ? subscribers.length : 0;
            setTimeout(function () {
                while (len--) subscribers[len].func(args);
            }, 0);

            return true;
        },
        subscribe       : function(message, func){
            return this.topicTree.mount(this.message2path(message), func);
        },
        unsubscribe     : function(tokenOrPath){
            var type    = typeof(tokenOrPath);
            if(type  == 'string'){//path
                return this.topicTree.unmountByPath(this.message2path(tokenOrPath));
            }else if(type == 'number'){//token
                return this.topicTree.unmountByToken(tokenOrPath);
            }
        }
    };

    return new PubSub;
}));

/*!
 * Small Walker - v0.1.1 - 5/5/2011
 * http://benalman.com/
 * 
 * Copyright (c) 2011 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
 
// Walk the DOM, depth-first (HTML order). Inside the callback, `this` is the
// element, and the only argument passed is the current depth. If the callback
// returns false, its children will be skipped.
// 
// Based on https://gist.github.com/240274
 
function walk(node, callback) {
    var depth   = 0,
        skip, tmp;
    // This depth value will be incremented as the depth increases and
    // decremented as the depth decreases. The depth of the initial node is 0.

    // Always start with the initial element.
    do {
        if ( !skip ) {
            // Call the passed callback in the context of node, passing in the
            // current depth as the only argument. If the callback returns false,
            // don't process any of the current node's children.
            skip = callback.call(node, depth) === false;
        }

        if ( !skip && (tmp = node.firstChild) ) {
          // If not skipping, get the first child. If there is a first child,
          // increment the depth since traversing downwards.
          depth++;
        } else if ( tmp = node.nextSibling ) {
          // If skipping or there is no first child, get the next sibling. If
          // there is a next sibling, reset the skip flag.
          skip = false;
        } else {
          // Skipped or no first child and no next sibling, so traverse upwards,
          tmp = node.parentNode;
          // and decrement the depth.
          depth--;
          // Enable skipping, so that in the next loop iteration, the children of
          // the now-current node (parent node) aren't processed again.
          skip = true;
        }

        // Instead of setting node explicitly in each conditional block, use the
        // tmp var and set it here.
        node = tmp;

        // Stop if depth comes back to 0 (or goes below zero, in conditions where
        // the passed node has neither children nore next siblings).
    } while ( depth > 0 );
};

var directives  = {
    'data-controller'   : function(value){
        console.log('set message root: /'+value)
		//set root to controller
    },
    'data-repeat'       : function(value){
        if( /(\w*) +in +(\w*)/gim.test(value) ){
			var R$1	= RegExp.$1,
				R$2	= RegExp.$2;
			//subscribe collects
			PubSub.subscribe(R$2 , (function(node, key){
				return function(data){

					
					console.log(node,key,data)
					var len	= data.length;
					while(len--){
					}
				}
			})(this, R$1));
			
			//set root to item
			/*subscribe template item
			PubSub.subscribe(R$2 + '.' + R$1, (function(){
				return function(){//when template change ,trigger it;
						
				}
			})(this))*/
        }
    },
    'data-model'        : function(){
    },
    'data-attribute-(.*)'    : function(value, attr){
        var flag        = false,
            len         = value.length,
            tmp         = '',
            l1,l2,func;

        while(len--){
            l1 = value[len];
            l2 = value[len-1];
            if(flag){
                if(l1 == '{' && l2 == '{'){
                    PubSub.subscribe(tmp, (function(node, attr){
                        return function(data){
                            node.setAttribute(attr,data);//only one template
                        }
                    })(this, attr));
                    flag    = false;
                    tmp     = '';
                    len --;
                }else if(l1 != ' '){
                    tmp = l1 + tmp;
                }
            }else if(!flag && l1 == '}' && l2 == '}'){
                flag    = true;
                len --;
            }
        }
    },
    'data-event-(.*)'     : function(value, evt){
        var flag    = false,
            len     = value.length,
            tmp     = '',
            l1,l2;

        while(len--){
            l1 = value[len];
            l2 = value[len-1];
            if(flag){
                if(l1 == '{' && l2 == '{'){
                    flag    = false;
                    PubSub.subscribe(tmp, (function(node){
                        return function(data){
                            //node.nodeValue  = data;
                        }
                    })(node));
                    tmp = '';
                    len --;
                }else{
                    tmp = l1 + tmp;
                }
            }else if(!flag && l1 == '}' && l2 == '}'){
                flag    = true;
                len --;
            }
        }
    }
};

walk(document.documentElement, function(depth, scopes) {
    if(this.nodeType == 1){
        var attributes  = this.attributes,
            len         = attributes.length,
            R           = RegExp,
            attribute;
        while(len--){
            attribute   = attributes[len];
            for(key in directives){
                if(new RegExp(key, "gim").test(attribute.nodeName))
                directives[key].call(this, attribute.nodeValue, R.$1, R.$2, R.$3, R.$4, R.$5, R.$6, R.$7, R.$8, R.$9);
            }
        }
    }else if(this.nodeType == 3){
        var flag    = false,
            hasTpl  = flag,
            node    = this,
            value   = node.nodeValue,
            len     = value.length,
            tmp     = '',
            tmp2    = '',
            i       = -1,
            parent  = node.parentNode,
            l1,l2,textNode;

        while(++i<len){
            l1 = value[i];
            l2 = value[i+1];
            if(flag){
                if(l1 == '}' && l2 == '}'){
                    textNode = node.cloneNode(false);
                    textNode.nodeValue  = '';
                    parent.insertBefore(textNode, node);
                    //subscribte
                    PubSub.subscribe(tmp, (function(node){
                        return function(data){
                            node.nodeValue  = data;
                        }
                    })(textNode));
                    flag    = false;
                    tmp     = '';
                    i++;
                }else{
                    tmp += l1;
                } 
            }else{
                if(l1 == '{' && l2 == '{'){
                    textNode = node.cloneNode(false);
                    textNode.nodeValue  = '';
                    parent.insertBefore(textNode, node);
                    flag    = hasTpl    = true;
                    tmp2    = '';
                    i++;
                }else if(l1 != ' '){
                    tmp2 += l1;
                }
            }
        }
        if(hasTpl) node.nodeValue  = '';
    }
});

PubSub.publish('phone.name', 'moto');
PubSub.publish('phone.snippet', 'snippet');
PubSub.publish('phone.img', 'img');
PubSub.publish('phone.name', 'moto2');
PubSub.publish('item.child', 'child');
PubSub.publish('phones',[1,2,3,4])
console.log(PubSub)
</script>
    <!--
    <div>2</div>
    <div data-controller="controller" id="1">1
        {{item.child}}ddlll
        dfdf
        <input type="text" data-model="item.child"/>
        <input type="text" data-model="phones[0].name"/>
        {{item.child}}
        <div data-controller="controller2" id="2">2
            <div data-attr-class="**_{{class.a}}" id="6">6
                <div data-controller id="9">9
                    <div id="13" data-controller="controller">13
                        <div data-evt-click="{{item.click}}" data-repeat="item in phones" id="16">{{item.name}}16
                            <div data-controller="controller2">{{class.a}}</div> 
                        </div>
                        <div data-attr-width="10" id="17">17
                            {{item.child}}
                            <div id="19">19</div>
                        </div>
                    </div>
                    <div id="14">14</div>
                </div>
            </div>
            <div id="7">7
                <div id="10" data-bind="{{class.a}}">10</div>
                <div data-controller id="11">11
                    <div id="15">15
                        <div data-controller id="18">18</div>
                    </div>
                </div>
                <div id="12">12</div>
            </div>
        </div>
        <div id="3">3</div>
        <div id="4">4
            <div id="8">8</div>
        </div>
        <div data-controller id="5">5</div>
    </div>-->
</body>
</html>
